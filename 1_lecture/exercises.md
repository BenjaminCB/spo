# Exercise Session 1
## Do Sebesta Review Questions 1 to 29 on page 54 to 55
1. Programming languages are useful for different things if you only know C making a website is suddenly quite cumbersome.
2. See example above
3. Fortran
4. Cobol
5. Lisp
6. html
7. It is hard for everyone to agree on the same score
8. If a language is big some people might learn different subsets of that language, thus in a small language we can circumvent this.
9. cant remember
10. Too many different ways to do the same thing (if i remember correctly)
11. If something is easy too write we can focus on other things such as optimizing an algorithm. Figuring out how to write something is not an obsticalle in and of itself.
12. Too many different ways to do the same thing (if i remember correctly)
13. `fmap`, `<$>` and `(<$>)` in Haskell
14. Checking that our data types give meaning no addition of numbers and strings
15. example above
16. Training programmers, writing programs, compiling, executing, implementation system, reliability, maintainability
17. Can it be used of different computers architectures
18. cant remember
19. get things from memory, perform action, put back into memory
20. no recursion, no dynamic lists
21. abstraction, polymorphism
22. simula or smalltalk (probably)
23. dynamic and static typing
24. compiler, interpreter, hybrid
25. compiler
26. keep track of information about symbols
27. links files and libraries
28. its a bottleneck
29. we can skip a lot of the steps that are in a compiler. If the implementation language is available on multiple platforms the source language will be as well.

## Use Table 1.1 on page 31 in Sebesta’s book to evaluate the C programming language
C is quite simple in its nature there the things that are needed but much more.

C has many basic data, the rest you will have to define yourself through structs and unions.

C has good and readable syntax, and serves as the basis for many over languages

C has very limited support for abstraction

C has some areas where you can be expressive, but not many

C has compile time type checking

C does not have exception handling

C probably has restricted aliasing.

## Use Table 1.1 on page 31 in Sebesta’s book to evaluate the C# or Java programming language (optional)

C# is not very simple is it a big language with a lot of boilerplate code, which is many cases is not needed

C# you can do many things in different ways, but for common problems there is often an over engineered design pattern

C# has basic data types but has classes and interfaces that allow for complex data types and polymorphism

C# has very good support for abstraction

C# you can be quite expressive the possible ways that you can use arrow notation

C# has good support for exception handling

C# probably has restricted aliasing.

## Do Fisher et al. exercise 3 on page 26 (exercise 5 page 55 in GE)

## Do Fisher et al. exercise 7 on page 28 (exercise 10 on page 57 in GE) (optional)

# Group exercises
Review your individual list of programming languages and make a new list of all the computer languages that group members know.

Categorize the above languages according to generations (1st to 5th (or 6th))

Categorize the above languages according to paradigm (imperative, object oriented, declarative, special)

Create a new list of language features group members would like in a new language. Are any of these features in conflict with each other? How would you prioritize the features?

Do Sebesta exercise 1, 2 and 3 page 55.

Do Sebesta exercise 4, 7, 10 and 17 page 56.

Do Sebesta exercise 18 page 56.

Do Fisher et al. Exercise 5 and 6 on page 27-28 (exercise 7 an 14 on page 56 resp. 58 in GE)

Do Fisher et al. Exercise 8 on page 28 (exercise 11 on page 57 in GE)
